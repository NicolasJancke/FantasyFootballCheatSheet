<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fantasy Football Cheat Sheet</title>

<!-- SortableJS -->
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>

<style>
  body {
    margin: 0;
    font-family: Arial, sans-serif;
  }

  /* Two-column layout */
  #app {
    display: flex;
    height: 100vh;
    padding: 1rem;
    gap: 1rem;
    box-sizing: border-box;
  }

  /* LEFT: Ranked tiers */
  #ranked-col {
    flex: 1;
    overflow-y: auto;
    padding-right: 1rem;
    border-right: 1px solid #ccc;
  }

  /* RIGHT: Unranked list and filters */
  #unranked-col {
    width: 350px;
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  h2 {
    margin: 0.3rem 0;
  }

  .tier {
    margin-bottom: 1rem;
  }

  .player-list {
    list-style: none;
    padding: 0;
    border: 1px solid #ccc;
    border-radius: 6px;
    min-height: 40px;
  }

  .player {
    background: #fff;
    border-bottom: 1px solid #eee;
    padding: 0.4rem 0.6rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .player:last-child {
    border-bottom: none;
  }

  .player-info {
    display: flex;
    gap: 0.4rem;
    align-items: center;
  }

  .position-tag {
    padding: 0.15rem 0.35rem;
    border-radius: 4px;
    color: white;
    font-weight: bold;
    font-size: 0.75rem;
  }

  .position-QB { background: #007bff; }
  .position-RB { background: #28a745; }
  .position-WR { background: #ffc107; color: black; }
  .position-TE { background: #fd7e14; }

  .rank-input {
    width: 55px;
    text-align: center;
  }

  /* right column elements */
  #filter {
    padding: 0.4rem;
    border-radius: 4px;
    border: 1px solid #aaa;
  }

  #position-buttons {
    display: flex;
    gap: 0.4rem;
  }

  .pos-btn {
    padding: 0.35rem 0.6rem;
    border: 1px solid #888;
    border-radius: 4px;
    background: #eee;
    cursor: pointer;
  }

  .pos-btn.active {
    background: #0077ff;
    color: white;
    border-color: #0055cc;
  }

  #tier-unranked {
    flex: 1;
    overflow-y: auto;
    padding: 0.3rem;
  }
</style>
</head>
<body>

<div id="app">

  <!-- LEFT COLUMN: RANKED PLAYERS -->
  <div id="ranked-col">
    <div class="tier" data-tier="1">
      <h2>Tier 1</h2>
      <ul id="tier-1" class="player-list"></ul>
    </div>

    <button id="add-tier">Add Tier</button>
    <button id="save">Save</button>
    <button id="reset">Reset</button>
    <button id="export-json">Export JSON</button>
    <input type="file" id="import-json" accept="application/json" style="display:none;">
    <button id="import-json-btn">Import JSON</button>

  </div>

  <!-- RIGHT COLUMN: UNRANKED PLAYERS -->
  <div id="unranked-col">
    <input id="filter" placeholder="Filter unranked players">

    <div id="position-buttons">
      <button class="pos-btn active" data-pos="">All</button>
      <button class="pos-btn" data-pos="QB">QB</button>
      <button class="pos-btn" data-pos="RB">RB</button>
      <button class="pos-btn" data-pos="WR">WR</button>
      <button class="pos-btn" data-pos="TE">TE</button>
    </div>

    <ul id="tier-unranked" class="player-list" data-tier="unranked"></ul>
  </div>

</div>

<script>
/* -------------------------
      GLOBALS
------------------------- */
let allPlayers = [];
let activePosFilter = "";
const sortableMap = new Map();

/* -------------------------
      FETCH PLAYERS
------------------------- */
async function fetchPlayers() {
  try {
    const resp = await fetch("https://api.sleeper.app/v1/players/nfl");
    return await resp.json();
  } catch (e) {
    console.error("Sleeper API error:", e);
    return {};
  }
}

/* -------------------------
    PLAYER ELEMENT FACTORY
------------------------- */
function createPlayerElement(id, p) {
  const li = document.createElement("li");
  li.classList.add("player");
  li.dataset.id = id;
  li.dataset.name = `${p.first_name || ""} ${p.last_name || ""}`.trim().toLowerCase();
  li.dataset.position = (p.position || "").toUpperCase();

  const info = document.createElement("div");
  info.classList.add("player-info");

  const tag = document.createElement("span");
  tag.classList.add("position-tag", `position-${li.dataset.position}`);
  tag.textContent = li.dataset.position;

  const label = document.createElement("span");
  const team = p.team ? ` (${p.team})` : "";
  label.textContent = `${p.first_name || ""} ${p.last_name || ""}${team}`;

  const rankInput = document.createElement("input");
  rankInput.type = "number";
  rankInput.min = 1;
  rankInput.classList.add("rank-input");
  rankInput.addEventListener("change", () => handleRankInput(li, rankInput));

  info.appendChild(tag);
  info.appendChild(label);

  li.appendChild(info);
  li.appendChild(rankInput);

  return li;
}

/* -------------------------
      SORTABLE HANDLING
------------------------- */
function initSortable(list, allowPut = true) {
  if (!list) return;

  if (sortableMap.has(list)) {
    sortableMap.get(list).destroy();
    sortableMap.delete(list);
  }

  const sortable = new Sortable(list, {
    group: { name: "tiers", pull: true, put: allowPut },
    animation: 150,
    onEnd: () => {
      updateRanks();
      saveDelayed();
    }
  });

  sortableMap.set(list, sortable);
}

/* -------------------------
      UPDATE RANKS
------------------------- */
function updateRanks() {
  document.querySelectorAll(".tier").forEach(tier => {
    if (tier.dataset.tier === "unranked") return;

    const players = tier.querySelectorAll(".player");
    players.forEach((p, i) => {
      const input = p.querySelector(".rank-input");
      input.value = i + 1;
    });
  });
}

/* -------------------------
  MANUAL RANK INPUT
------------------------- */
function handleRankInput(player, input) {
  const tier = player.closest(".tier");
  if (!tier || tier.dataset.tier === "unranked") return;

  const list = tier.querySelector(".player-list");
  const players = [...list.children];

  let newRank = parseInt(input.value);
  if (isNaN(newRank) || newRank < 1) newRank = 1;
  if (newRank > players.length) newRank = players.length;

  const curIndex = players.indexOf(player);
  if (curIndex === newRank - 1) return;

  list.insertBefore(player, players[newRank - 1] || null);
  updateRanks();
  saveDelayed();
}

/* -------------------------
        SAVE
------------------------- */
let saveTimeout;
function saveDelayed() {
  clearTimeout(saveTimeout);
  saveTimeout = setTimeout(saveRankings, 800);
}

function saveRankings() {
  const data = {};
  document.querySelectorAll(".player-list").forEach(list => {
    data[list.id] = [...list.querySelectorAll(".player")].map(p => p.dataset.id);
  });
  localStorage.setItem("rankings", JSON.stringify(data));
}

function loadRankings() {
  const saved = JSON.parse(localStorage.getItem("rankings") || "{}");
  for (const [listId, ids] of Object.entries(saved)) {
    const list = document.getElementById(listId);
    if (!list) continue;
    ids.forEach(id => {
      const el = document.querySelector(`.player[data-id="${id}"]`);
      if (el) list.appendChild(el);
    });
  }
}

/* -------------------------
        FILTERING
     (UNRANKED ONLY)
------------------------- */
function applyFilters() {
  const nameFilter = filter.value.toLowerCase();

  document.querySelectorAll("#tier-unranked .player").forEach(p => {
    const matchName = !nameFilter || p.dataset.name.includes(nameFilter);
    const matchPos = !activePosFilter || p.dataset.position === activePosFilter;
    p.style.display = matchName && matchPos ? "" : "none";
  });
}

/* -------------------------
      INIT APP
------------------------- */
document.addEventListener("DOMContentLoaded", async () => {

  /* Buttons for filtering */
  document.querySelectorAll(".pos-btn").forEach(btn => {
    btn.addEventListener("click", () => {
      document.querySelectorAll(".pos-btn").forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      activePosFilter = btn.dataset.pos;
      applyFilters();
    });
  });

  filter.addEventListener("input", applyFilters);

  document.getElementById("reset").addEventListener("click", () => {
    localStorage.removeItem("rankings");
    location.reload();
  });

  document.getElementById("save").addEventListener("click", saveRankings);

  // ============================
// EXPORT / IMPORT JSON
// ============================

// Export rankings as JSON file
function exportRankingsJSON() {
  const tiers = {};
  document.querySelectorAll(".player-list").forEach((list) => {
    const tierId = list.id;
    tiers[tierId] = Array.from(list.querySelectorAll(".player")).map(
      (p) => p.dataset.id
    );
  });

  const blob = new Blob([JSON.stringify(tiers, null, 2)], {
    type: "application/json",
  });

  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "rankings.json";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// Apply imported data after Sleeper players exist
function applyImportedRankings(imported) {
  // Clear all lists first
  document.querySelectorAll(".player-list").forEach((list) => {
    list.innerHTML = "";
  });

  // For every tier in JSON, put matching players
  for (const [tierId, playerIds] of Object.entries(imported)) {
    const list = document.getElementById(tierId);
    if (!list) {
      console.warn("Tier not found in layout:", tierId);
      continue;
    }

    playerIds.forEach((id) => {
      const el = document.querySelector(`.player[data-id="${id}"]`);
      if (el) list.appendChild(el);
      else console.warn("Player not found in Sleeper data:", id);
    });
  }

  updateRanks();
  delayedSave();
}

// Read JSON and prepare to load it
function importRankingsJSON(file) {
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const imported = JSON.parse(e.target.result);

      // Wait until all players are loaded
      const waitForPlayers = setInterval(() => {
        if (document.querySelectorAll(".player").length > 0) {
          clearInterval(waitForPlayers);
          applyImportedRankings(imported);
        }
      }, 100);
    } catch (err) {
      alert("Invalid JSON file.");
      console.error(err);
    }
  };
  reader.readAsText(file);
}

// Wire export/import buttons
document.getElementById("export-json").addEventListener("click", exportRankingsJSON);

document.getElementById("import-json-btn").addEventListener("click", () => {
  document.getElementById("import-json").click();
});

document.getElementById("import-json").addEventListener("change", (e) => {
  const file = e.target.files[0];
  if (file) importRankingsJSON(file);
});


  document.getElementById("add-tier").addEventListener("click", () => {
    const existing = [...document.querySelectorAll(".tier")]
      .map(t => t.dataset.tier)
      .filter(t => t !== "unranked")
      .map(Number);

    const next = existing.length ? Math.max(...existing) + 1 : 1;

    const div = document.createElement("div");
    div.classList.add("tier");
    div.dataset.tier = next;

    const h = document.createElement("h2");
    h.textContent = `Tier ${next}`;

    const ul = document.createElement("ul");
    ul.id = `tier-${next}`;
    ul.classList.add("player-list");

    div.appendChild(h);
    div.appendChild(ul);

    document.getElementById("ranked-col").insertBefore(
      div,
      document.getElementById("add-tier")
    );

    initSortable(ul, true);
  });

  /* LOAD PLAYERS */
  const data = await fetchPlayers();

  allPlayers = Object.entries(data)
    .map(([id, p]) => ({ id, ...p }))
    .filter(p => ["QB", "RB", "WR", "TE"].includes((p.position || "").toUpperCase()))
    .sort((a, b) => (a.last_name || "").localeCompare(b.last_name || ""));

  const unrankedEl = document.getElementById("tier-unranked");

  allPlayers.forEach(p => {
    const el = createPlayerElement(p.id, p);
    unrankedEl.appendChild(el);
  });

  /* init sortables */
  document.querySelectorAll(".player-list").forEach(list => initSortable(list, true));

  /* then apply saved ranking */
  loadRankings();
  updateRanks();
});
</script>

</body>
</html>
